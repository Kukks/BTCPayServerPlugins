@using BTCPayServer.Abstractions.Contracts
@using BTCPayServer.Abstractions.Models
@using BTCPayServer.Client.Models
@using BTCPayServer.Data
@using BTCPayServer.HostedServices
@using BTCPayServer.Lightning
@using BTCPayServer.Payments
@using BTCPayServer.PayoutProcessors
@using BTCPayServer.Payouts
@using BTCPayServer.Plugins.PointOfSale
@using BTCPayServer.Plugins.Prism.ViewModel
@using BTCPayServer.Services.Apps
@using Microsoft.AspNetCore.Http
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Mvc.Rendering
@using Microsoft.AspNetCore.Routing
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Logging
@using NBitcoin
@using LightningAddressData = BTCPayServer.Data.LightningAddressData
@using MarkPayoutRequest = BTCPayServer.HostedServices.MarkPayoutRequest
@inject IPluginHookService PluginHookService
@inject LightningAddressService LightningAddressService
@inject PayoutProcessorService PayoutProcessorService
@inject IEnumerable<IPayoutProcessorFactory> PayoutProcessorFactories
@inject SatBreaker SatBreaker
@inject LinkGenerator LinkGenerator
@inject PullPaymentHostedService PullPaymentHostedService
@inject IHttpContextAccessor HttpContextAccessor
@inject ILogger<PrismEdit> Logger
@inject EventAggregator EventAggregator
@inject AppService AppService
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider AuthStateProvider
@implements IDisposable

@if (Loading)
{
    <div class="d-flex justify-content-center p-5">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else
{
    <datalist id="users">
        <option value="*">Catch-all lightning payments made against invoices in your store (excluding when other prisms are configured that capture those payments.)</option>
        <option value="*@PaymentTypes.CHAIN.ToString()">Catch-all on-chain payments made against invoices in your store</option>
        <option value="*All">Catch-all any payments made against invoices in your store</option>

        @foreach (var user in Users)
        {
            <option value="@user.Username">@user.Username: (lightning address)</option>
        }
    </datalist>
    <datalist id="destinations">
        @foreach (var destination in Destinations)
        {
            <option value="@destination">@destination</option>
        }
    </datalist>
    <datalist id="availableStores">
        @foreach (var destination in Destinations)
        {
            <option value="@destination">@destination (alias)</option>
        }
        @foreach (var s in AvailableStores)
        {
            <option value="@s.Value">@s.Text (store)</option>
        }
    </datalist>

    <EditForm EditContext="EditContext" OnValidSubmit="Save">

        <div class="sticky-header-setup"></div>
        <div class="sticky-header d-sm-flex align-items-center justify-content-between">
            <h2 class="mb-0">
                Prism
                <a href="https://dergigi.com/2023/03/12/lightning-prisms/" class="ms-1" target="_blank" rel="noreferrer noopener">
                    <span class="fa fa-question-circle-o text-secondary" title="More information..."></span>
                </a>
            </h2>
            <div class="d-flex gap-2 mt-3 mt-sm-0">
                @if (SelectedDestinationId is null or "null")
                {
                    <div class="btn-group">
                        <button type="button" class="btn btn-primary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                            Add
                        </button>
                        <ul class="dropdown-menu">
                            <li><button type="button" class="dropdown-item" @onclick="CreateNewPrism">Split</button></li>
                            <li><button type="button" class="dropdown-item" @onclick="CreateNewWalletTransfer">Wallet Transfer</button></li>
                        </ul>
                    </div>
                    <select class="form-select" style="max-width: fit-content" @bind="SelectedDestinationId">
                        <option value="null">Destinations</option>
                        @foreach (var destination in Destinations)
                        {
                            <option value="@destination">@destination</option>
                        }
                        <option value="">+ New</option>
                    </select>
                }

                @if (PrismEditButtonsFilter is not null)
                {
                    @((MarkupString) PrismEditButtonsFilter)
                }
            </div>
        </div>

        @if (NoPayoutProcessors)
        {
            <div class="alert alert-warning mb-5" role="alert">
                An automated payout processor is required in order to automate prism payouts.
                <a class="alert-link p-0" href="@PayoutProcessorLink">Configure now</a>
            </div>
        }

        @if (StatusMessageModel != null)
        {
            <div class="alert alert-@StatusMessageModel.ToString(StatusMessageModel.Severity)">
                @StatusMessageModel.Message
            </div>
        }

        <div id="prism-holder">
            <div class="prism">
                @if (SelectedDestinationId is null or "null")
                {
                    <!-- Settings Row -->
                    <div class="d-flex align-items-center gap-4 mb-4 p-3 bg-light rounded flex-wrap">
                        <div class="d-flex align-items-center gap-2" title="Enable or disable all prism processing for this store">
                            <input @bind="Settings.Enabled" @bind:after="SaveGlobalSettings" type="checkbox" class="btcpay-toggle" id="prism-enabled"/>
                            <label for="prism-enabled" class="mb-0">Enabled</label>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <label class="mb-0 text-nowrap" title="Minimum sats to accumulate before creating a payout">Threshold:</label>
                            <input type="number" @bind="Settings.SatThreshold" @bind:after="SaveGlobalSettings" min="1" class="form-control form-control-sm" style="width: 100px"
                                   title="Minimum sats to accumulate before creating a payout. Higher values reduce fees but delay payments."/>
                            <span class="text-muted">sats</span>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <label class="mb-0 text-nowrap" title="Percentage to reserve from payouts to cover network fees">Reserve:</label>
                            <input type="number" @bind="Settings.Reserve" @bind:after="SaveGlobalSettings" min="0" max="100" step="any" class="form-control form-control-sm" style="width: 80px"
                                   title="Percentage of each payout reserved to cover network fees. Remaining balance carries over."/>
                            <span class="text-muted">%</span>
                        </div>
                    </div>

                    <!-- Prisms -->
                    @foreach (var item in Settings.Splits.Where(s => s.Source is null || !s.Source.StartsWith("pos:")))
                    {
                        <PrismSplit Split="@item" OnRequestRemove="@RemovePrism" OnSave="@SaveSettings" OnSaveForce="@SaveSettingsForce"/>
                    }

                    <!-- POS Product Splits Section -->
                    @if (PosProducts.Any())
                    {
                        <div class="mt-5">
                            <h2>POS Product Splits</h2>
                            <p class="text-muted">Configure automatic splits for Point of Sale product purchases.</p>

                            <div class="alert alert-info">
                                <strong>Note:</strong> Ensure the calculated split amount exceeds the sat threshold, and that you have a payout processor configured for the selected payment method.
                            </div>

                            <div class="accordion" id="posAccordion">
                                @for (int i = 0; i < PosProducts.Count; i++)
                                {
                                    var app = PosProducts[i];
                                    <div class="accordion-item mb-3" @key="app.AppId">
                                        <h2 class="accordion-header">
                                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#pos-@app.AppId">
                                                @app.AppTitle
                                                <span class="badge bg-secondary ms-2">@app.Products.Count products</span>
                                            </button>
                                        </h2>
                                        <div id="pos-@app.AppId" class="accordion-collapse collapse" data-bs-parent="#posAccordion">
                                            <div class="accordion-body">
                                                <div class="row g-3">
                                                    @foreach (var product in app.Products)
                                                    {
                                                        <div class="col-md-6 col-lg-4" @key="product.ProductId">
                                                            <div class="card h-100">
                                                                <div class="card-body">
                                                                    <h5 class="card-title">@product.Title</h5>
                                                                    <p class="text-muted mb-2">Price: @product.Price @product.Currency</p>

                                                                    @foreach (var d in product.Destinations)
                                                                    {
                                                                        <div class="row g-2 mb-2 align-items-center">
                                                                            <div class="col-3">
                                                                                <input type="number" class="form-control form-control-sm"
                                                                                       min="0" max="100" placeholder="%"
                                                                                       @bind="d.Percentage" @bind:event="oninput">
                                                                            </div>
                                                                            <div class="col-3">
                                                                                <select class="form-select form-select-sm" @bind="d.PaymentMethod">
                                                                                    <option value="BTC-CHAIN">Chain</option>
                                                                                    <option value="BTC-LN">LN</option>
                                                                                </select>
                                                                            </div>
                                                                            <div class="col-6 d-flex gap-1">
                                                                                <input type="text" class="form-control form-control-sm"
                                                                                       @bind="d.Destination" placeholder="Store/Address" />
                                                                                <button type="button" class="btn btn-sm btn-outline-danger"
                                                                                        @onclick="() => product.Destinations.Remove(d)">x</button>
                                                                            </div>
                                                                        </div>
                                                                    }
                                                                    <button type="button" class="btn btn-sm btn-outline-primary w-100"
                                                                            @onclick="() => product.Destinations.Add(new ProductDestinationRow())">
                                                                        + Add split
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                }
                else
                {
                    @if (SelectedDestinationId is not null && SelectedDestinationId != "null")
                    {
                        switch (SelectedDestinationId)
                        {
                            case "":
                                <h2>Create new Destination</h2>
                                break;
                            default:
                                <h2>Editing @SelectedDestinationId Destination</h2>
                                break;
                        }

                        <PrismDestinationEditor
                            StoreId="@StoreId"
                            ValidateId="ValidateId"
                            ValidateDestination="s => ValidateDestinationSimple(s, false)"
                            Id="@SelectedDestinationId"
                            Settings="@SelectedDestination"
                            OnUpdate="OnDestinationUpdated"
                            OnCancel="() => SelectedDestinationId = null">
                        </PrismDestinationEditor>
                    }
                }
            </div>
        </div>
        <PrismBalances
            OnUpdate="OnUpdateBalance"
            OnCancelPayout="CancelPayout"
            DestinationBalance="Settings.DestinationBalance"
            PendingPayouts="Settings.PendingPayouts">
        </PrismBalances>

    </EditForm>
}

@code {
    [Parameter] public string StoreId { get; set; }

    private void AddDestination()
    {
        SelectedDestinationId = "";
        StateHasChanged();
    }

    public string? SelectedDestinationId { get; set; } = "null";

    public PrismDestination? SelectedDestination
    {
        get
        {
            if (SelectedDestinationId is null or "null")
                return null;
            Settings.Destinations.TryGetValue(SelectedDestinationId, out var res);
            return res;
        }
    }

    public string[] Destinations => Settings.Destinations.Select(kv => kv.Key).ToArray();

    public string[] AllDestinationAliases => Settings.Destinations.Keys.ToArray();

    public bool Loading { get; set; } = true;
    public List<LightningAddressData> Users { get; set; } = new();
    public PayoutMethodId pmi { get; set; } = PayoutTypes.LN.GetPayoutMethodId("BTC");
    public PayoutMethodId pmichain { get; set; } = PayoutTypes.CHAIN.GetPayoutMethodId("BTC");
    public bool NoPayoutProcessors { get; set; }

    private string PrismEditButtonsFilter { get; set; }

    // Available stores for transfer destinations
    List<SelectListItem> AvailableStores = new();

    // POS Products
    List<PosAppProductSplitModel> PosProducts = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            PrismEditButtonsFilter = (await PluginHookService.ApplyFilter("prism-edit-buttons", "")) as string;
            PayoutProcessorLink = LinkGenerator.GetUriByAction(HttpContextAccessor.HttpContext, "ConfigureStorePayoutProcessors", "UIPayoutProcessors", new {StoreId});
            LNAddressLink = LinkGenerator.GetUriByAction(HttpContextAccessor.HttpContext, "EditLightningAddress", "UILNURL", new {StoreId});
            PayoutsLink = LinkGenerator.GetUriByAction(HttpContextAccessor.HttpContext, "Payouts", "UIStorePullPayments", new {StoreId, payoutState = PayoutState.AwaitingPayment, paymentMethodId = pmi.ToString()});

            var fetchSettings = SatBreaker.Get(StoreId);
            var fetchLnAddresses = LightningAddressService.Get(new LightningAddressQuery()
            {
                StoreIds = new[] {StoreId}
            });
            var fetchProcessors = PayoutProcessorService.GetProcessors(new PayoutProcessorService.PayoutProcessorQuery()
            {
                Stores = new[] {StoreId},
                PayoutMethods = new[] {pmi, pmichain}
            });

            await Task.WhenAll(fetchSettings, fetchLnAddresses, fetchProcessors);
            Settings = await fetchSettings;
            Users = await fetchLnAddresses;

            // Load available stores for transfer destinations
            await LoadAvailableStores();

            // Load POS products
            await LoadPosProducts();

            EditContext = new EditContext(Settings);
            MessageStore = new ValidationMessageStore(EditContext);
            EditContext.OnValidationRequested += Validate;
            EditContext.OnFieldChanged += FieldChanged;
            SatBreaker.PrismUpdated += SatBreakerOnPrismUpdated;

            NoPayoutProcessors = PayoutProcessorFactories.Any(factory => factory.GetSupportedPayoutMethods().Contains(pmi)) && (await fetchProcessors).All(data =>
                !new[] {pmi, pmichain}.Contains(data.GetPayoutMethodId()));

            Loading = false;
            await InvokeAsync(StateHasChanged);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    async Task LoadAvailableStores()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated ?? false)
        {
            var userId = UserManager.GetUserId(user);
            var appUser = await UserManager.Users
                .Where(c => c.Id == userId)
                .Include(u => u.UserStores)
                .ThenInclude(us => us.StoreData)
                .SingleOrDefaultAsync();

            var stores = appUser?.UserStores
                .Where(s => s.StoreDataId != StoreId && !s.StoreData.Archived)
                .Select(s => s.StoreData)
                .ToList() ?? new();

            AvailableStores = stores.Select(s => new SelectListItem { Value = s.Id, Text = s.StoreName }).ToList();
        }
    }

    async Task LoadPosProducts()
    {
        var storePosApps = (await AppService.GetApps(PointOfSaleAppType.AppType)).Where(c => c.StoreDataId == StoreId && !c.Archived).ToList();
        if (storePosApps.Any())
        {
            var posSplits = Settings.Splits.Where(s => s.Source.StartsWith("pos:")).ToList();
            PosProducts = storePosApps.Select(app =>
            {
                var settings = app.GetSettings<PointOfSaleSettings>();
                var products = new List<ProductSplitItemModel>();
                if (!string.IsNullOrEmpty(settings?.Template))
                {
                    var templateItems = AppService.Parse(settings.Template) ?? Array.Empty<AppItem>();
                    products = templateItems.Select(item =>
                    {
                        var split = posSplits.FirstOrDefault(s => s.Source == $"pos:{app.Id}:{item.Id}");
                        return new ProductSplitItemModel
                        {
                            ProductId = item.Id,
                            Title = item.Title,
                            Price = item.Price ?? 0m,
                            Currency = settings.Currency,
                            Destinations = split?.Destinations
                                .Select(d =>
                                {
                                    var parts = d.Destination.Split(':', 3);
                                    return new ProductDestinationRow
                                    {
                                        Destination = parts.Length > 1 ? parts[1] : string.Empty,
                                        PaymentMethod = parts.Length > 2 ? parts[2] : "BTC-LN",
                                        Percentage = (int)d.Percentage
                                    };
                                }).ToList() ?? new List<ProductDestinationRow>()
                        };
                    }).ToList();
                }
                return new PosAppProductSplitModel
                {
                    AppId = app.Id,
                    AppTitle = app.Name,
                    Products = products
                };
            }).ToList();
        }
    }

    private void FieldChanged(object sender, FieldChangedEventArgs e)
    {
        StatusMessageModel = null;
    }

    private void SatBreakerOnPrismUpdated(object sender, PrismPaymentDetectedEventArgs e)
    {
        if (e.StoreId != StoreId) return;
        if (e.Settings != Settings && e.Settings.Version != Settings.Version)
        {
            Settings.DestinationBalance = e.Settings.DestinationBalance;
            Settings.PendingPayouts = e.Settings.PendingPayouts;
            Settings.Version = e.Settings.Version;
        }

        InvokeAsync(StateHasChanged);
    }

    private void Validate(object sender, ValidationRequestedEventArgs validationRequestedEventArgs)
    {
        var previousState = EditContext.GetValidationMessages().Any();
        MessageStore.Clear();
        StatusMessageModel = null;

        // Validate regular prisms (not POS or wallet transfers)
        foreach (var prism in Settings.Splits.Where(c => c.Source is null || !(c.Source.StartsWith("pos") || c.Source.StartsWith("storetransfer"))))
        {
            if (string.IsNullOrEmpty(prism.Source))
            {
                MessageStore.Add(() => prism.Source, "Source is required");
            }
            else if (Settings.Splits.Count(s => s.Source == prism.Source) > 1)
            {
                MessageStore.Add(() => prism.Source, "Sources must be unique");
            }

            ValidateSplitDestinations(prism);
        }

        // Validate wallet transfers (storetransfer: sources)
        foreach (var transfer in Settings.Splits.Where(c => c.Source?.StartsWith("storetransfer") == true))
        {
            var parsed = SatBreaker.ParseSource(transfer.Source);
            PayoutMethodId expectedPayoutMethod = null;
            if (parsed?.paymentMethod != null)
            {
                var pmStr = parsed.Value.paymentMethod.ToString();
                expectedPayoutMethod = pmStr.Contains("LN")
                    ? PayoutTypes.LN.GetPayoutMethodId("BTC")
                    : PayoutTypes.CHAIN.GetPayoutMethodId("BTC");
            }
            ValidateSplitDestinations(transfer, expectedPayoutMethod);
        }

        if (previousState != EditContext.GetValidationMessages().Any())
            EditContext.NotifyValidationStateChanged();
    }

    private void ValidateSplitDestinations(Split prism, PayoutMethodId expectedPayoutMethod = null)
    {
        if (!(prism.Destinations?.Count > 0))
        {
            MessageStore.Add(() => prism.Destinations, "At least one destination is required");
            return;
        }

        var sum = prism.Destinations.Sum(d => d.Percentage);
        if (sum > 100)
        {
            MessageStore.Add(() => prism.Destinations, "Destinations must sum up to a 100 maximum");
        }

        foreach (var destination in prism.Destinations)
        {
            var dest = destination.Destination;
            if (string.IsNullOrEmpty(dest))
            {
                MessageStore.Add(() => destination.Destination, "Destination is required");
                continue;
            }

            var validationResult = ValidateDestination(dest, allowAlias: true, expectedPayoutMethod);
            if (!validationResult.success)
            {
                MessageStore.Add(() => destination.Destination, validationResult.error ?? "Destination is not valid");
            }
        }
    }

    private (bool success, string error) ValidateDestination(string dest, bool allowAlias, PayoutMethodId expectedPayoutMethod = null)
    {
        // If it's an alias, resolve to underlying destination
        string rawDestination = dest;
        if (allowAlias && Settings.Destinations.TryGetValue(dest, out var aliasedDest))
        {
            rawDestination = aliasedDest.Destination;
        }
        
        // For wallet transfers, if the destination is a raw store ID, convert to store-prism format
        if (expectedPayoutMethod != null && !rawDestination.StartsWith("store-prism:", StringComparison.OrdinalIgnoreCase))
        {
            var matchingStore = AvailableStores.FirstOrDefault(s => s.Value == rawDestination);
            if (matchingStore != null)
            {
                var paymentMethodStr = expectedPayoutMethod.ToString().Contains("LN") ? "BTC-LN" : "BTC-CHAIN";
                rawDestination = $"store-prism:{rawDestination}:{paymentMethodStr}";
            }
        }

        // Validate the raw destination (use Task.Run to avoid sync-over-async deadlock in Blazor)
        var result = Task.Run(() => PluginHookService.ApplyFilter("prism-destination-validate", rawDestination)).GetAwaiter().GetResult();

        if (result is not PrismDestinationValidationResult validationResult || !validationResult.Success)
        {
            return (false, "Destination is not valid");
        }

        // Check payment method compatibility if expected
        if (expectedPayoutMethod != null && validationResult.PayoutMethodId != null)
        {
            if (validationResult.PayoutMethodId != expectedPayoutMethod)
            {
                var expectedType = expectedPayoutMethod.ToString().Contains("LN") ? "Lightning" : "On-chain";
                var actualType = validationResult.PayoutMethodId.ToString().Contains("LN") ? "Lightning" : "On-chain";
                return (false, $"Destination is {actualType} but transfer is {expectedType}");
            }
        }

        return (true, null);
    }

    private bool ValidateDestinationSimple(string dest, bool allowAlias)
    {
        return ValidateDestination(dest, allowAlias).success;
    }

    public ValidationMessageStore MessageStore { get; set; }

    public EditContext? EditContext { get; set; }
    public StatusMessageModel StatusMessageModel { get; set; }

    public PrismSettings Settings { get; set; }

    public string PayoutProcessorLink { get; set; }

    public string LNAddressLink { get; set; }
    public string PayoutsLink { get; set; }

    private async Task CreateNewPrism()
    {
        Settings.Splits.Add(new Split());
        await InvokeAsync(StateHasChanged);
    }

    private async Task CreateNewWalletTransfer()
    {
        // Create a wallet transfer with default schedule (1st of month)
        var source = SatBreaker.EncodeSource(new SatBreaker.TransferSchedule(SatBreaker.TransferFrequency.Monthly, 1), PaymentMethodId.Parse("BTC-CHAIN"), null);
        Settings.Splits.Add(new Split { Source = source });
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemovePrism(Split item)
    {
        if (Settings.Splits.Remove(item))
        {
            await SaveSettingsForce();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveSettingsForce()
    {
        // Save without validation - used for remove operations
        await SatBreaker.WaitAndLock();
        try
        {
            var settz = SatBreaker.GetInternal(StoreId);
            settz.Splits = Settings.Splits;
            settz.Destinations = Settings.Destinations;
            settz.Enabled = Settings.Enabled;
            settz.SatThreshold = Settings.SatThreshold;
            settz.Reserve = Settings.Reserve;
            Settings = settz;
            await SatBreaker.UpdatePrismSettingsForStore(StoreId, settz, true);
        }
        finally
        {
            SatBreaker.Unlock();
        }
    }

    private async Task<bool> SaveSettings()
    {
        // Normalize wallet transfer destinations before validation
        NormalizeWalletTransferDestinations();
        
        // Trigger validation
        if (EditContext?.Validate() == false)
        {
            return false;
        }

        await SatBreaker.WaitAndLock();
        try
        {
            var settz = SatBreaker.GetInternal(StoreId);
            settz.Splits = Settings.Splits;
            settz.Destinations = Settings.Destinations;
            settz.Enabled = Settings.Enabled;
            settz.SatThreshold = Settings.SatThreshold;
            settz.Reserve = Settings.Reserve;
            Settings = settz;
            await SatBreaker.UpdatePrismSettingsForStore(StoreId, settz, true);
            return true;
        }
        finally
        {
            SatBreaker.Unlock();
        }
    }
    
    private void NormalizeWalletTransferDestinations()
    {
        // For wallet transfers, convert raw store IDs to store-prism format
        foreach (var transfer in Settings.Splits.Where(c => c.Source?.StartsWith("storetransfer") == true))
        {
            var parsed = SatBreaker.ParseSource(transfer.Source);
            if (parsed?.paymentMethod == null) continue;
            
            var paymentMethodStr = parsed.Value.paymentMethod.ToString().Contains("LN") ? "BTC-LN" : "BTC-CHAIN";
            
            foreach (var destination in transfer.Destinations)
            {
                if (string.IsNullOrEmpty(destination.Destination)) continue;
                if (destination.Destination.StartsWith("store-prism:", StringComparison.OrdinalIgnoreCase)) continue;
                
                // Check if it's an alias - if so, skip (will be resolved during validation/execution)
                if (Settings.Destinations.ContainsKey(destination.Destination)) continue;
                
                // Check if it's a store ID
                var matchingStore = AvailableStores.FirstOrDefault(s => s.Value == destination.Destination);
                if (matchingStore != null)
                {
                    destination.Destination = $"store-prism:{destination.Destination}:{paymentMethodStr}";
                }
            }
        }
    }

    private async Task SaveGlobalSettings()
    {
        await SaveSettings();
    }

    private async Task SaveDestinations()
    {
        await SatBreaker.WaitAndLock();
        try
        {
            var settz = SatBreaker.GetInternal(StoreId);
            settz.Destinations = Settings.Destinations;
            Settings = settz;
            await SatBreaker.UpdatePrismSettingsForStore(StoreId, settz, true);
        }
        finally
        {
            SatBreaker.Unlock();
        }
    }

    private async Task Save()
    {
        await SatBreaker.WaitAndLock();
        try
        {
            var settz = SatBreaker.GetInternal(StoreId);
            settz.Splits = Settings.Splits;
            settz.Destinations = Settings.Destinations;
            settz.Enabled = Settings.Enabled;
            settz.SatThreshold = Settings.SatThreshold;
            settz.Reserve = Settings.Reserve;

            // Save POS product splits
            settz.Splits.RemoveAll(s => s.Source.StartsWith("pos:"));
            foreach (var app in PosProducts)
            {
                foreach (var product in app.Products)
                {
                    var validDestinations = product.Destinations
                        .Where(d => d.Percentage is > 0 && !string.IsNullOrEmpty(d.Destination))
                        .Select(d => new BTCPayServer.Plugins.Prism.PrismSplit
                        {
                            Destination = $"store-prism:{d.Destination}:{d.PaymentMethod}",
                            Percentage = Math.Min(100, d.Percentage.Value)
                        }).ToList();

                    if (validDestinations.Any())
                    {
                        if (validDestinations.Sum(d => d.Percentage) > 100)
                        {
                            StatusMessageModel = new()
                            {
                                Severity = StatusMessageModel.StatusSeverity.Error,
                                Message = $"POS product '{product.Title}': percentages cannot exceed 100%"
                            };
                            return;
                        }

                        settz.Splits.Add(new Split
                        {
                            Source = $"pos:{app.AppId}:{product.ProductId}",
                            Destinations = validDestinations
                        });
                    }
                }
            }

            Settings = settz;
            await UpdateAndShowResult(settz, true);
        }
        finally
        {
            SatBreaker.Unlock();
        }
        
    }

    private async Task UpdateAndShowResult(PrismSettings settz, bool skipLock)
    {
        var updateResult = await SatBreaker.UpdatePrismSettingsForStore(StoreId, settz, skipLock);

        if (!updateResult)
        {
            StatusMessageModel = new StatusMessageModel()
            {
                Severity = StatusMessageModel.StatusSeverity.Error,
                Message = "The settings have been updated by another process. Please refresh the page and try again."
            };
        }
        else
        {
            StatusMessageModel = new StatusMessageModel()
            {
                Severity = StatusMessageModel.StatusSeverity.Success,
                Message = "Successfully saved settings"
            };
        }
    }

    public void Dispose()
    {
        if (EditContext is not null)
        {
            EditContext.OnValidationRequested -= Validate;
            EditContext.OnFieldChanged -= FieldChanged;
        }

        SatBreaker.PrismUpdated -= SatBreakerOnPrismUpdated;
    }

    private bool ValidateId(string arg)
    {
        if (string.IsNullOrEmpty(arg))
            return false;

        if (SelectedDestinationId == arg)
        {
            return true;
        }

        if (Destinations.Contains(arg))
        {
            return false;
        }

        return true;
    }

    private async Task OnUpdateBalance((string destination, long newBalance) obj)
    {
        try
        {
            await SatBreaker.WaitAndLock();
            if (obj.newBalance == 0)
            {
                Settings.DestinationBalance.Remove(obj.destination);
            }
            else
            {
                Settings.DestinationBalance.AddOrReplace(obj.destination, obj.newBalance);
            }

            await SatBreaker.UpdatePrismSettingsForStore(StoreId, Settings, true);
            SatBreaker.TriggerPayoutCheck();
        }
        finally
        {
            SatBreaker.Unlock();
        }
    }

    private async Task OnDestinationUpdated((string Id, PrismDestination? Destination) obj)
    {
        if (obj.Destination is null && !string.IsNullOrEmpty(SelectedDestinationId))
        {
            Settings.Destinations.Remove(SelectedDestinationId);

            foreach (var settingsSplit in Settings.Splits)
            {
                settingsSplit.Destinations.RemoveAll(split => split.Destination == SelectedDestinationId);
            }

            await SaveSettingsForce();
            SelectedDestinationId = null;
            await InvokeAsync(StateHasChanged);
        }

        else
        {
            if (string.IsNullOrEmpty(SelectedDestinationId))
            {
                SelectedDestinationId = obj.Id;
            }

            Settings.Destinations.AddOrReplace(SelectedDestinationId, obj.Destination);
            await SaveDestinations();
            var needSave = false;
            if (!string.IsNullOrEmpty(SelectedDestinationId) && SelectedDestinationId != obj.Id)
            {
                try
                {
                    await SatBreaker.WaitAndLock();

                    foreach (var destination in Settings.Splits.SelectMany(split => split.Destinations.Where(destination => destination.Destination == SelectedDestinationId)))
                    {
                        destination.Destination = obj.Id;
                        needSave = true;
                    }

                    if (Settings.DestinationBalance.Remove(SelectedDestinationId, out var db))
                    {
                        needSave = true;
                        Settings.DestinationBalance.Add(obj.Id, db);
                    }

                    if (Settings.Destinations.Remove(SelectedDestinationId, out var dest))
                    {
                        needSave = true;
                        Settings.Destinations.Add(obj.Id, dest);
                    }

                    if (needSave)
                    {
                        await SatBreaker.UpdatePrismSettingsForStore(StoreId, Settings, true);
                    }
                }
                finally
                {
                    SatBreaker.Unlock();
                }
            }

            SelectedDestinationId = "null";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CancelPayout((string payoutId, TaskCompletionSource tcs) payout)
    {
        try
        {
            var result = (await PullPaymentHostedService.Cancel(
                new PullPaymentHostedService.CancelRequest(new[] {payout.payoutId}, new[] {StoreId}))).First().Value;

            StatusMessageModel = new StatusMessageModel()
            {
                Severity = result == MarkPayoutRequest.PayoutPaidResult.Ok ? StatusMessageModel.StatusSeverity.Success : StatusMessageModel.StatusSeverity.Error,
                Message = result switch
                {
                    MarkPayoutRequest.PayoutPaidResult.Ok => "Payout cancelled (please note that if the threshold is still within reach, a new payout will be created in its place)",
                    MarkPayoutRequest.PayoutPaidResult.NotFound => "Payout not found",
                    MarkPayoutRequest.PayoutPaidResult.InvalidState => "Payout state was in a non-cancellable state.",
                    _ => "Unknown error"
                }
            };
            if (result == MarkPayoutRequest.PayoutPaidResult.Ok)
            {
                SatBreaker.TriggerPayoutCheck();
            }
        }
        finally
        {
            payout.tcs.TrySetResult();
        }
    }
}
