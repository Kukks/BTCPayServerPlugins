@using Microsoft.AspNetCore.Mvc.Rendering

@if (HasData)
{
    <div class="card mt-4">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0" title="Funds accumulated per destination and pending payouts waiting to be processed">Balances & Payouts</h5>
        </div>
        <div class="card-body">
            <div class="table-responsive">
            <table class="table table-sm mb-0 w-100">
                <thead>
                    <tr>
                        <th>Destination</th>
                        <th class="text-end">Amount</th>
                        <th>Status</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var item in GetUnifiedData())
                    {
                        <tr>
                            <td style="max-width: 200px">
                                <DestinationDisplay 
                                    Destination="@item.Destination"
                                    Destinations="@Destinations"
                                    AvailableStores="@AvailableStores"
                                    Truncate="true"
                                    ShowAliasIndicator="true" />
                            </td>
                            <td class="text-end">
                                @item.Amount.ToString("N0") sats@if (item.FeeCharged > 0)
                                {<small class="text-muted" title="Reserve fee charged"> (-@item.FeeCharged.ToString("N0") fee)</small>}
                            </td>
                            <td>
                                @if (item.HasPayout)
                                {
                                    <span class="badge bg-warning text-dark" title="A payout has been created and is waiting to be processed by the payout processor">Payout pending</span>
                                }
                                else
                                {
                                    <span class="badge bg-secondary" title="Funds are accumulating until the threshold is reached">Accumulating</span>
                                }
                            </td>
                            <td class="text-end">
                                @if (item.HasPayout)
                                {
                                    <button type="button" class="btn btn-sm btn-outline-danger"
                                            @onclick="() => CancelPayout(item.PayoutId)"
                                            disabled="@IsActionOngoing"
                                            title="Cancel this pending payout and return funds to the accumulating balance">Cancel</button>
                                }
                                else if (UpdatingDestination == item.Destination)
                                {
                                    <div class="d-flex gap-1 justify-content-end">
                                        <input type="number" @bind="UpdatingValue" min="0" class="form-control form-control-sm" style="width: 100px"
                                               title="New balance in sats"/>
                                        <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="() => UpdatingDestination = null" title="Cancel editing">Ã—</button>
                                        <button type="button" class="btn btn-sm btn-outline-primary" @onclick="Update" disabled="@IsActionOngoing" title="Save new balance">Save</button>
                                    </div>
                                }
                                else
                                {
                                    <button type="button" class="btn btn-sm btn-outline-secondary"
                                            @onclick="() => StartUpdate(item.Destination, item.RawBalance)"
                                            disabled="@IsActionOngoing"
                                            title="Manually adjust the accumulated balance for this destination">Edit</button>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
            </div>
        </div>
    </div>
}

@code {
    private string? UpdatingDestination { get; set; }
    private long? UpdatingValue { get; set; }
    private bool IsActionOngoing { get; set; }

    [Parameter]
    public Dictionary<string, long> DestinationBalance { get; set; }

    [Parameter]
    public Dictionary<string, PendingPayout> PendingPayouts { get; set; }
    
    /// <summary>
    /// Dictionary of alias -> PrismDestination for resolving aliases
    /// </summary>
    [Parameter]
    public Dictionary<string, PrismDestination> Destinations { get; set; }
    
    /// <summary>
    /// List of available stores for resolving store-prism destinations to friendly names
    /// </summary>
    [Parameter]
    public List<SelectListItem> AvailableStores { get; set; }

    [Parameter]
    public EventCallback<(string destination, long newBalance)> OnUpdate { get; set; }

    [Parameter]
    public EventCallback<(string payoutId, TaskCompletionSource tcs)> OnCancelPayout { get; set; }

    private bool HasData => (DestinationBalance?.Any() == true) || (PendingPayouts?.Any() == true);

    private record UnifiedRow(string Destination, decimal Amount, long RawBalance, bool HasPayout, string? PayoutId, long FeeCharged);

    private IEnumerable<UnifiedRow> GetUnifiedData()
    {
        var result = new Dictionary<string, UnifiedRow>();

        // Add balances
        if (DestinationBalance != null)
        {
            foreach (var (dest, balance) in DestinationBalance)
            {
                result[dest] = new UnifiedRow(dest, balance / 1000m, balance, false, null, 0);
            }
        }

        // Override with payouts (payout takes precedence in display)
        if (PendingPayouts != null)
        {
            foreach (var (payoutId, payout) in PendingPayouts)
            {
                var dest = payout.DestinationId;
                var amount = payout.PayoutAmount > 0 ? payout.PayoutAmount : payout.ScheduledTransferAmount;
                result[dest] = new UnifiedRow(dest, amount, 0, true, payoutId, payout.FeeCharged);
            }
        }

        return result.Values.OrderBy(r => r.Destination);
    }

    private void StartUpdate(string dest, long balance)
    {
        UpdatingDestination = dest;
        UpdatingValue = (long)Math.Min(long.MaxValue, balance / 1000);
    }

    private async Task Update()
    {
        if (UpdatingDestination is null || UpdatingValue is null)
        {
            return;
        }
        await OnUpdate.InvokeAsync((UpdatingDestination, Convert.ToInt64(UpdatingValue.Value * 1000m)));
        UpdatingDestination = null;
    }

    private async Task CancelPayout(string payoutId)
    {
        UpdatingDestination = null;
        IsActionOngoing = true;
        try
        {
            var tcs = new TaskCompletionSource();
            await OnCancelPayout.InvokeAsync((payoutId, tcs));
            await tcs.Task;
        }
        finally
        {
            IsActionOngoing = false;
        }
    }
}
