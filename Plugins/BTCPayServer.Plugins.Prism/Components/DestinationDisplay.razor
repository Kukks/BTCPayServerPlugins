@using Microsoft.AspNetCore.Mvc.Rendering

@* 
    Displays a destination in a friendly format with type icons.
    Can resolve:
    - Aliases (from Destinations dictionary)
    - store-prism:storeId:paymentMethod -> Store name with icon
    - Lightning addresses -> address with lightning icon
    - Bitcoin addresses -> truncated address with bitcoin icon
*@

<span class="destination-display @(Clickable ? "destination-clickable" : "")" 
      @onclick="HandleClick" 
      title="@GetTooltip()"
      style="@(Clickable ? "cursor: pointer;" : "")">
    <span class="destination-icon me-1">@GetIcon()</span>
    <span class="destination-text @(Truncate ? "text-truncate" : "")" style="@(Truncate ? "max-width: 150px; display: inline-block; vertical-align: bottom;" : "")">@GetDisplayText()</span>
    @if (IsAlias && ShowAliasIndicator)
    {
        <span class="badge bg-light text-dark ms-1" title="This is a saved destination alias">alias</span>
    }
</span>

@code {
    /// <summary>
    /// The raw destination string (could be alias, store-prism:..., lightning address, bitcoin address, etc.)
    /// </summary>
    [Parameter] public string Destination { get; set; }
    
    /// <summary>
    /// Dictionary of alias -> PrismDestination for resolving aliases
    /// </summary>
    [Parameter] public Dictionary<string, PrismDestination> Destinations { get; set; }
    
    /// <summary>
    /// List of available stores for resolving store-prism destinations to friendly names
    /// </summary>
    [Parameter] public List<SelectListItem> AvailableStores { get; set; }
    
    /// <summary>
    /// Whether to truncate long addresses
    /// </summary>
    [Parameter] public bool Truncate { get; set; } = true;
    
    /// <summary>
    /// Whether clicking should trigger an action
    /// </summary>
    [Parameter] public bool Clickable { get; set; } = false;
    
    /// <summary>
    /// Show "alias" badge for aliased destinations
    /// </summary>
    [Parameter] public bool ShowAliasIndicator { get; set; } = true;
    
    /// <summary>
    /// Callback when clicked (if Clickable is true)
    /// </summary>
    [Parameter] public EventCallback<string> OnClick { get; set; }

    private bool IsAlias => !string.IsNullOrEmpty(Destination) && 
                            Destinations?.ContainsKey(Destination) == true;

    private string ResolvedDestination => IsAlias 
        ? Destinations[Destination].Destination 
        : Destination;

    private DestinationType GetDestinationType()
    {
        var dest = ResolvedDestination;
        if (string.IsNullOrEmpty(dest)) return DestinationType.Unknown;
        
        if (dest.StartsWith("store-prism:", StringComparison.OrdinalIgnoreCase))
        {
            var parts = dest.Split(':', 3);
            var paymentMethod = parts.Length > 2 ? parts[2] : "";
            return paymentMethod.Contains("LN") ? DestinationType.StoreLightning : DestinationType.StoreOnChain;
        }
        
        // Lightning address (contains @)
        if (dest.Contains("@") && !dest.Contains("://"))
        {
            return DestinationType.LightningAddress;
        }
        
        // LNURL
        if (dest.StartsWith("lnurl", StringComparison.OrdinalIgnoreCase))
        {
            return DestinationType.LNURL;
        }
        
        // Bitcoin address (starts with common prefixes)
        if (dest.StartsWith("bc1", StringComparison.OrdinalIgnoreCase) ||
            dest.StartsWith("1") ||
            dest.StartsWith("3") ||
            dest.StartsWith("tb1", StringComparison.OrdinalIgnoreCase) ||
            dest.StartsWith("m") ||
            dest.StartsWith("n") ||
            dest.StartsWith("2"))
        {
            return DestinationType.BitcoinAddress;
        }
        
        // xpub
        if (dest.StartsWith("xpub", StringComparison.OrdinalIgnoreCase) ||
            dest.StartsWith("tpub", StringComparison.OrdinalIgnoreCase))
        {
            return DestinationType.Xpub;
        }
        
        return DestinationType.Unknown;
    }

    private string GetIcon()
    {
        return GetDestinationType() switch
        {
            DestinationType.StoreLightning => "ðŸªâš¡",
            DestinationType.StoreOnChain => "ðŸª",
            DestinationType.LightningAddress => "âš¡",
            DestinationType.LNURL => "âš¡",
            DestinationType.BitcoinAddress => "â‚¿",
            DestinationType.Xpub => "â‚¿",
            _ => "ðŸ“"
        };
    }

    private string GetDisplayText()
    {
        if (string.IsNullOrEmpty(Destination)) return "(none)";
        
        // If it's an alias, show the alias name
        if (IsAlias)
        {
            return Destination;
        }
        
        var dest = ResolvedDestination;
        var destType = GetDestinationType();
        
        // Store transfer - try to resolve store name
        if (destType == DestinationType.StoreLightning || destType == DestinationType.StoreOnChain)
        {
            var parts = dest.Split(':', 3);
            var storeId = parts.Length > 1 ? parts[1] : "";
            var storeName = AvailableStores?.FirstOrDefault(s => s.Value == storeId)?.Text;
            return storeName ?? storeId;
        }
        
        // Lightning address - show as-is
        if (destType == DestinationType.LightningAddress)
        {
            return dest;
        }
        
        // LNURL - truncate if needed
        if (destType == DestinationType.LNURL && Truncate && dest.Length > 20)
        {
            return dest.Substring(0, 17) + "...";
        }
        
        // Bitcoin address / xpub - truncate
        if ((destType == DestinationType.BitcoinAddress || destType == DestinationType.Xpub) && Truncate && dest.Length > 16)
        {
            return dest.Substring(0, 8) + "..." + dest.Substring(dest.Length - 6);
        }
        
        return dest;
    }

    private string GetTooltip()
    {
        if (string.IsNullOrEmpty(Destination)) return "";
        
        var lines = new List<string>();
        
        if (IsAlias)
        {
            lines.Add($"Alias: {Destination}");
            lines.Add($"Destination: {ResolvedDestination}");
            
            var aliasConfig = Destinations[Destination];
            if (aliasConfig.SatThreshold.HasValue)
                lines.Add($"Threshold: {aliasConfig.SatThreshold} sats");
            if (aliasConfig.Reserve.HasValue)
                lines.Add($"Reserve: {aliasConfig.Reserve}%");
        }
        else
        {
            lines.Add(ResolvedDestination);
        }
        
        var destType = GetDestinationType();
        var typeLabel = destType switch
        {
            DestinationType.StoreLightning => "Store Transfer (Lightning)",
            DestinationType.StoreOnChain => "Store Transfer (On-chain)",
            DestinationType.LightningAddress => "Lightning Address",
            DestinationType.LNURL => "LNURL",
            DestinationType.BitcoinAddress => "Bitcoin Address",
            DestinationType.Xpub => "Extended Public Key",
            _ => "Destination"
        };
        lines.Insert(0, typeLabel);
        
        return string.Join("\n", lines);
    }

    private async Task HandleClick()
    {
        if (Clickable && OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(Destination);
        }
    }

    private enum DestinationType
    {
        Unknown,
        StoreLightning,
        StoreOnChain,
        LightningAddress,
        LNURL,
        BitcoinAddress,
        Xpub
    }
}
