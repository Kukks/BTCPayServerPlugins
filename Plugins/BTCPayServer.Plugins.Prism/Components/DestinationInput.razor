@using BTCPayServer.Data
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Mvc.Rendering
@using Microsoft.EntityFrameworkCore
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider AuthStateProvider

<div class="destination-input">
    <div class="form-group">
        <label class="form-label">Destination Type</label>
        <select class="form-select" @bind="DestinationType" disabled="@Disabled">
            <option value="address">Lightning Address / LNURL / Address</option>
            <option value="store">Store Transfer</option>
        </select>
    </div>

    @if (DestinationType == "address")
    {
        <div class="form-group">
            <label class="form-label">Destination</label>
            <input type="text" @bind="AddressValue" @bind:event="oninput" @bind:after="OnAddressChanged" 
                   class="form-control" disabled="@Disabled" placeholder="Enter lightning address, LNURL, bitcoin address, or xpub"/>
            @if (Invalid)
            {
                <span class="text-danger w-100">@ValidationError</span>
            }
            <span class="form-text">Can be a lightning address, LNURL, bitcoin address, or xpub</span>
        </div>
    }
    else
    {
        <div class="row">
            <div class="col-md-8">
                <div class="form-group">
                    <label class="form-label">Destination Store</label>
                    <select class="form-select" @bind="SelectedStoreId" @bind:after="OnStoreChanged" disabled="@Disabled">
                        <option value="">Select a store...</option>
                        @foreach (var store in AvailableStores)
                        {
                            <option value="@store.Value">@store.Text</option>
                        }
                    </select>
                    @if (Invalid)
                    {
                        <span class="text-danger w-100">@ValidationError</span>
                    }
                </div>
            </div>
            <div class="col-md-4">
                <div class="form-group">
                    <label class="form-label">Payment Method</label>
                    <select class="form-select" @bind="StorePaymentMethod" @bind:after="OnStoreChanged" disabled="@Disabled">
                        <option value="BTC-CHAIN">On-chain</option>
                        <option value="BTC-LN">Lightning</option>
                    </select>
                </div>
            </div>
        </div>
    }

    @if (ShowThresholdAndReserve)
    {
        <div class="form-group">
            <label class="form-label">Sat Threshold</label>
            <input type="number" @bind="SatThreshold" min="1" class="form-control" disabled="@Disabled" placeholder="Use default"/>
            <span class="form-text">How many sats to accumulate before sending? Leave blank to use default setting.</span>
        </div>
        <div class="form-group">
            <label class="form-label">Reserve fee</label>
            <input type="number" @bind="Reserve" min="0" max="100" class="form-control" disabled="@Disabled" placeholder="Use default"/>
            <span class="form-text">Percentage excluded from payout to cover fees. Leave blank to use default setting.</span>
        </div>
    }
</div>

@code {
    [Parameter] public string StoreId { get; set; }
    [Parameter] public bool Disabled { get; set; } = false;
    [Parameter] public bool ShowThresholdAndReserve { get; set; } = true;
    [Parameter] public Func<string, bool> ValidateDestination { get; set; }
    [Parameter] public EventCallback<DestinationInputResult> OnChange { get; set; }
    
    /// <summary>
    /// Filter to only show destinations compatible with a specific payment method.
    /// If null, shows all destination types.
    /// </summary>
    [Parameter] public string PaymentMethodFilter { get; set; }

    /// <summary>
    /// Initial value to populate the input with
    /// </summary>
    [Parameter] public string InitialDestination { get; set; }
    
    [Parameter] public long? InitialSatThreshold { get; set; }
    [Parameter] public decimal? InitialReserve { get; set; }

    private string DestinationType { get; set; } = "address";
    private string AddressValue { get; set; } = "";
    private string SelectedStoreId { get; set; } = "";
    private string StorePaymentMethod { get; set; } = "BTC-LN";
    private long? SatThreshold { get; set; }
    private decimal? Reserve { get; set; }
    
    private bool Invalid { get; set; } = false;
    private string ValidationError { get; set; } = "Invalid";
    
    private List<SelectListItem> AvailableStores { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadAvailableStores();
        ParseInitialDestination();
        SatThreshold = InitialSatThreshold;
        Reserve = InitialReserve;
    }

    protected override void OnParametersSet()
    {
        // Apply payment method filter
        if (!string.IsNullOrEmpty(PaymentMethodFilter))
        {
            if (PaymentMethodFilter.Contains("LN"))
            {
                StorePaymentMethod = "BTC-LN";
            }
            else if (PaymentMethodFilter.Contains("CHAIN"))
            {
                StorePaymentMethod = "BTC-CHAIN";
            }
        }
    }

    private async Task LoadAvailableStores()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated ?? false)
        {
            var userId = UserManager.GetUserId(user);
            var appUser = await UserManager.Users
                .Where(c => c.Id == userId)
                .Include(u => u.UserStores)
                .ThenInclude(us => us.StoreData)
                .SingleOrDefaultAsync();

            var stores = appUser?.UserStores
                .Where(s => s.StoreDataId != StoreId && !s.StoreData.Archived)
                .Select(s => s.StoreData)
                .ToList() ?? new();

            AvailableStores = stores.Select(s => new SelectListItem { Value = s.Id, Text = s.StoreName }).ToList();
        }
    }

    private void ParseInitialDestination()
    {
        if (string.IsNullOrEmpty(InitialDestination)) return;

        if (InitialDestination.StartsWith("store-prism:", StringComparison.OrdinalIgnoreCase))
        {
            DestinationType = "store";
            var parts = InitialDestination.Split(':', 3);
            SelectedStoreId = parts.Length > 1 ? parts[1] : "";
            StorePaymentMethod = parts.Length > 2 ? parts[2] : "BTC-LN";
        }
        else
        {
            DestinationType = "address";
            AddressValue = InitialDestination;
        }
    }

    private async Task OnAddressChanged()
    {
        await EmitChange();
    }

    private async Task OnStoreChanged()
    {
        await EmitChange();
    }

    private async Task EmitChange()
    {
        var result = BuildResult();
        Invalid = false;
        ValidationError = "Invalid";

        if (!string.IsNullOrEmpty(result.Destination))
        {
            if (DestinationType == "store" && string.IsNullOrEmpty(SelectedStoreId))
            {
                Invalid = true;
                ValidationError = "Please select a store";
            }
            else if (DestinationType == "address" && ValidateDestination != null && !ValidateDestination(AddressValue))
            {
                Invalid = true;
                ValidationError = "Invalid destination";
            }
        }

        result.IsValid = !Invalid && !string.IsNullOrEmpty(result.Destination);
        await OnChange.InvokeAsync(result);
    }

    private DestinationInputResult BuildResult()
    {
        string destination;
        if (DestinationType == "store")
        {
            destination = string.IsNullOrEmpty(SelectedStoreId) 
                ? "" 
                : $"store-prism:{SelectedStoreId}:{StorePaymentMethod}";
        }
        else
        {
            destination = AddressValue ?? "";
        }

        return new DestinationInputResult
        {
            Destination = destination,
            SatThreshold = SatThreshold,
            Reserve = Reserve,
            IsValid = false, // Will be set by EmitChange
            IsStoreTransfer = DestinationType == "store",
            StoreId = DestinationType == "store" ? SelectedStoreId : null,
            StoreName = DestinationType == "store" ? AvailableStores.FirstOrDefault(s => s.Value == SelectedStoreId)?.Text : null,
            PaymentMethod = DestinationType == "store" ? StorePaymentMethod : null
        };
    }

    /// <summary>
    /// Validates and returns the current destination. Call this before using the result.
    /// </summary>
    public DestinationInputResult Validate()
    {
        var result = BuildResult();
        Invalid = false;
        ValidationError = "Invalid";

        if (string.IsNullOrEmpty(result.Destination))
        {
            Invalid = true;
            ValidationError = "Destination is required";
        }
        else if (DestinationType == "store" && string.IsNullOrEmpty(SelectedStoreId))
        {
            Invalid = true;
            ValidationError = "Please select a store";
        }
        else if (DestinationType == "address" && ValidateDestination != null && !ValidateDestination(AddressValue))
        {
            Invalid = true;
            ValidationError = "Invalid destination";
        }

        result.IsValid = !Invalid;
        StateHasChanged();
        return result;
    }

    public class DestinationInputResult
    {
        public string Destination { get; set; }
        public long? SatThreshold { get; set; }
        public decimal? Reserve { get; set; }
        public bool IsValid { get; set; }
        public bool IsStoreTransfer { get; set; }
        public string StoreId { get; set; }
        public string StoreName { get; set; }
        public string PaymentMethod { get; set; }
    }
}
